pragma solidity ^0.4.11;

contract Splitter {
    // Mapping between addresses and how much money they have withdrawn. This is
    // used to calculate the balance of each account. The public keyword allows
    // reading from the map but not writing to the map using the
    // amountsWithdrew(address) method of the contract.
    mapping(address => uint) public amountsWithdrew;

    // A list of parties to split the funds between. When adding elements to the
    // between mapping, remember to update count, otherwise the split will be
    // uneven.
    uint8 count;
    mapping(address => bool) between;

    // The total amount of funds which has been deposited into the contract.
    uint public totalInput;

    function Splitter() {
        // Initialize the state of the contract. You should probably change
        // these addresses otherwise funds will be inacessible to you. These
        // addresses are used when running `truffle test`. They are generated by
        // `testrpc --deterministic`.

        count = 2;
        between[0x0090f8bf6a479f320ead074411a4b0e7944ea8c9c1] = true;
        between[0x00ffcf8fdee72ac11b5c542428b35eef5769c409f0] = true;
    }

    // To save on transaction fees, it's beneficial to withdraw in one big
    // transaction instead of many little ones. That's why a withdrawl flow is
    // being used.

    // We do integer division (floor(a / b)) when calculating each share, because
    // solidity doesn't have a decimal number type. This means there will be a
    // maximum remainder of count - 1 wei locked in the contract. We ignore this
    // because it is such a small amount of ethereum (1 Wei = 10^(-18)
    // Ethereum). The extra Wei can be extracted by depositing an amount to make
    // totalInput evenly divisable between count parties.

    /// @notice Withdraws from the sender's share of funds and deposits into the
    /// sender's account. If there are insufficient funds in the contract, or
    /// more than the share is being withdrawn, throws, canceling the
    /// transaction.
    /// @param amount The amount of funds in wei to withdraw from the contract.
    function withdraw(uint amount) {
        // Require the withdrawer to be a specified.
        require(between[msg.sender] == true);

        // Ensures the funds are available to make the transfer, otherwise
        // throws.
        uint withdrew = amountsWithdrew[msg.sender];
        uint share = totalInput / count;
        uint available = share - withdrew;

        assert(available >= 0);
        require(available >= amount);

        // Updates the internal state, this is done before the transfer to
        // prevent re-entrancy bugs.
        amountsWithdrew[msg.sender] += amount;

        // Transfer funds from the contract to the sender. The gas for this
        // transaction is paid for by msg.sender.
        msg.sender.transfer(amount);
    }

    /// @notice Withdraws all funds available to the sender and deposits them
    /// into the sender's account.
    function withdrawAll() {
        uint share = totalInput / count;
        uint withdrew = amountsWithdrew[msg.sender];
        uint available = share - withdrew;

        Splitter.withdraw(available);
    }

    // This function will be run when a transaction is sent to the contract
    // without any data. It is minimal to save on gas costs.
    function() payable {
        totalInput += msg.value;
    }
}
